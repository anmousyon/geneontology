{
    "collab_server" : "",
    "contents" : "library(RBGL)\nlibrary(GO.db)\nlibrary(GOSim)\nlibrary(GOSemSim)\nlibrary(GOstats)\nlibrary(RBGL)\nlibrary(arules)\n\nsource(\"helperFunctions.R\")\ngenes <-read.table(\"../genes.txt\")\nannot<-read.csv(file =\"../gene_association/human_association.txt\",header = F)\n\nontology<-\"F\";\nsetOntology(\"MF\", loadIC=FALSE)\n\n##select the right configuration for the chosen ontology\nif (ontology=='P') {\n  rootTerm<-\"GO:0008150\";\n  ontoenv <- GOBPANCESTOR;\n  parents <- GOBPPARENTS\n  offspring <- as.list(GOBPOFFSPRING);\n  ont =\"BP\"\n} else if (ontology==\"F\") {\n  rootTerm<-\"GO:0003674\"\n  ontoenv <- GOMFANCESTOR\n  parents <- GOMFPARENTS\n  offspring <- as.list(GOMFOFFSPRING)\n  ont = \"MF\"\n}  else if (ontology==\"C\") {\n  rootTerm<-\"GO:0005575\"\n  ontoenv <- GOCCANCESTOR\n  parents <- GOCCPARENTS\n  offspring <- as.list(GOCCOFFSPRING)\n  ont = \"CC\"\n}\n\n##set ancestors\nancestors<-ontoenv\n\n##initialize thresholds\ndepthThreshold <- 4\noffspringThreshold <- 200\n\n\n\n#####\n\n# find annotation\n##get fthird column of gene annotation and store in list (set since unique)\ngenes <- unique(as.character(annot[,3]))\n#conceptsMat<-matrix(nrow=length(genes), ncol=20)\n##create a matrix of size 5000*60\nconceptsMat<-matrix(nrow=5000, ncol=60)\n##create an empty list to store the concepts\nconceptsList<-list()\n##?\nctr<-1\n# go through all genes and find terms from\n##for all genes in list\n#for(i in 1:length(genes)) {\nfor(i in 1:500) {\n  ##get all the information for that gene, for specific ontology\n  annotTerms<-annot[annot[,3]==genes[i] & annot[,9]==ontology & annot[,7]!=\"IEA\",]\n  ##get fifth column of annotation and store in list (set since unique)\n  goTerms<-unique(as.character(annotTerms[,5]))\n  ##if there are less than two terms then skip this gene\n  if (length(goTerms)<2) \n    next\n  ##store the depths of all the terms in a list\n  depths<-sapply(goTerms, findDepth)\n  ##if none of the terms have a depth greater than 2 then skip this gene\n  if (max(depths)<2) next;\n  \n  ##create a vector to store the concepts\n  concepts<-vector()\n  # loop through all terms to generalize concepts\n  while(length(goTerms)>0){\n    # always start with first term and then remove when done\n    t<-goTerms[1]\n    ##if there are at least two terms left\n    if (length(goTerms)>1) {\n      ##otherterms is all terms that are not the same as the first one (t)?\n      otherTerms <- goTerms[-which(goTerms==t)]\n      ##find lca by using the findLCA helper function\n      lca<-as.character(sapply(otherTerms, FUN=function(k) findLCA(t,k)))\n      ##find depth using lcaDepth helper function\n      lcadepth<-sapply(lca, findDepth)\n      ##find offspring using lcaOffspringCount helper function\n      lcaOffspringCount<-sapply(lca, findOffspringCount)\n      # find lca with max depth\n      ##if any of the terms have a depth greater than the threshold\n      if (max(lcadepth) > depthThreshold) {\n        ##store greatest term depth\n        maxIndex <- which.max(lcadepth)\n        # remove the first and the closest term\n        ##remove first term using -1 and closest using -(maxindex+1)\n        goTerms<-goTerms[-c(1,maxIndex+1)]\n        # replace with their lca if not already there\n        ##if the term with the max depth isnt in goTerms\n        if (!lca[maxIndex] %in% goTerms)\n          ##add it to the goTerms list?\n          goTerms<-c(lca[maxIndex],goTerms)\n      }\n      ##if no terms have a depth greater than the threshold\n      else {\n        ##store the concept of the first term\n        concepts<-c(concepts,goTerms[1])\n        ##remove the first element from the list\n        goTerms<-goTerms[-1]\n      }\n    }\n    ##if there is only one term\n    else { # only one term left \n      ##store the concept of the first term\n      concepts<-c(concepts, goTerms[1])\n      ##remove the first element from the list\n      goTerms<-goTerms[-1]\n    }\n  }\n  # write concepts vector in a file\n  ##store gene i in row=ctr column=1\n  conceptsMat[ctr,1]<-genes[i]\n  ##create a new vector\n  lstVector<-vector()\n  ##for every concepyt\n  for(j in 1:length(concepts)) {\n    ##insert the concept into matrix at row=ctr column = j+1\n    ##format will be [gene, c1, c2, c3, c4, ...]\n    conceptsMat[ctr,j+1]<-concepts[j]\n    #conceptsList[[ctr]][j]<-concepts[j]\n    ##append the concept to lstVector\n    lstVector<-c(lstVector,concepts[j])\n  }\n  ##append the list of concepts to the concept list\n  ##will be list of lists?\n  conceptsList<-c(conceptsList,list(lstVector))\n  names(conceptsList)[ctr]<-genes[i]\n  rm(lstVector)\n  ##increment the row number?\n  ctr<-ctr+1\n}\nwrite.table(conceptsMat,file=paste(\"../concepts_\",ont,\"_thres_\",depthThreshold,\".txt\",sep=\"\"))\n# perform association analysis on list\n##get all the transactions for the concepts\ntrans<-as(conceptsList,\"transactions\")\nsaveRDS(trans, file=paste(\"../trans_\",ont,\"_thres_\",depthThreshold,\".RDS\",sep=\"\"))\nsummary(trans)\n## generating rules\nrules<-apriori(trans,parameter = list(supp = 0.001, conf = 0.8))\ninspect(rules)\n##sort the rules by their lift value\nrules_high_lift<-sort(rules,by=\"lift\")\nwrite(rules_high_lift, file=paste(\"../rules_\",ont,\"_thresh_\",depthThreshold,\"_sort_lift.txt\", sep=\"\"), sep=\"\\t\", col.names=NA)\n",
    "created" : 1474565381914.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1298152181",
    "id" : "48B92F1D",
    "lastKnownWriteTime" : 1474964114,
    "last_content_update" : 1474964114487,
    "path" : "~/Repos/geneontology/code/findAssociation.R",
    "project_path" : "findAssociation.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}